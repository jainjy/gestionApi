// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_DATABASE_URL")
  relationMode = "prisma"
}

// ======================
// ARTICLES
// ======================
model BlogArticle {
  id          String    @id @default(uuid())
  authorId    String
  title       String
  slug        String    @unique
  content     String
  excerpt     String?
  coverUrl    String?
  tags        String[]
  category    String
  status      String    @default("draft")
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now())
  views       Int       @default(0)
  likes       Int       @default(0)
  comments    Int       @default(0)
  readTime    String?

  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

// ======================
// UTILISATEUR
// ======================
model User {
  id                String               @id @default(uuid())
  email             String               @unique
  passwordHash      String?
  provider          Json?
  firstName         String?
  lastName          String?
  phone             String?
  role              String               @default("user")
  avatar            String? // Logo ou avatar de l'utilisateur
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  resetToken        String?
  resetTokenExpiry  DateTime?
  blogArticles      BlogArticle[]
  status            String               @default("inactive")
  companyName       String?
  demandType        String? //agence immobilier,particulier ou syndicat 
  address           String? // Adresse postale
  zipCode           String? // Code postal
  city              String? // Ville
  addressComplement String? // Complément d'adresse
  commercialName    String? // Nom commercial
  siret             String? // Numéro SIRET
  providerName String?   // ex: "google"
  providerId   String?   // ex: "117349..."
  userType          String? // PRESTATAIRE | VENDEUR | LOUEUR | CLIENT | ADMIN
  // Nouvelles relations
  properties        Property[]
  favorites         Favorite[]
  metiers           UtilisateurMetier[]
  services          UtilisateurService[]
  demandesCrees     Demande[]            @relation("DemandeCreePar")
  demandesArtisan   DemandeArtisan[]     @relation("DemandeArtisanUser")
  Product           Product[]
  latitude          Float?
  longitude         Float?
  Transaction       Transaction[]
}

// ======================
// PROPRIÉTÉS ET FAVORIS
// ======================
model Property {
  id          String  @id @default(uuid())
  title       String
  description String?
  type        String // "house", "apartment", "villa", "land", "studio"
  status      String // "draft", "pending", "published", "archived", "sold", "rented"
  price       Float?
  rentType    String? @default("longue_duree") // "saisonniere" | "longue_duree"

  // Caractéristiques principales
  surface   Int? // Surface en m²
  rooms     Int? // Nombre de pièces
  bedrooms  Int? // Nombre de chambres
  bathrooms Int? // Nombre de salles de bain

  // Localisation
  address   String?
  city      String
  zipCode   String?
  latitude  Float?
  longitude Float?

  // Équipements
  features String[] // ["pool", "garden", "parking", "terrace", "balcony"]

  // Images
  images String[] // URLs des images

  // Métadonnées
  isFeatured Boolean @default(false)
  isActive   Boolean @default(true)
  views      Int     @default(0)

  // Nouvelles colonnes ajoutées
  listingType String  @default("sale") // "sale", "rent", "both"
  energyClass String? // "A", "B", "C", "D", "E", "F", "G"
  yearBuilt   Int?
  floor       Int? // Étage
  totalFloors Int? // Nombre total d'étages
  hasElevator Boolean @default(false)
  hasParking  Boolean @default(false)
  hasBalcony  Boolean @default(false)
  hasTerrace  Boolean @default(false)
  hasGarden   Boolean @default(false)
  hasPool     Boolean @default(false)

  // SEO
  metaTitle       String?
  metaDescription String?
  slug            String? @unique

  // Relations
  ownerId   String
  owner     User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  favorites Favorite[]

  // Dates
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?
  expiresAt   DateTime? // Date d'expiration de l'annonce

  @@index([city])
  @@index([type])
  @@index([status])
  @@index([ownerId])
  @@index([isActive])
  @@index([isFeatured])
  @@index([listingType])
  @@index([createdAt])
}

model Favorite {
  id         String   @id @default(uuid())
  userId     String
  propertyId String
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([userId, propertyId])
  @@index([userId])
  @@index([propertyId])
}

// ======================
// PRODUIT
// ======================
model Product {
  id            String  @id @default(uuid())
  userId        String
  name          String
  slug          String  @unique
  description   String?
  category      String
  subcategory   String?
  price         Float
  comparePrice  Float? // Prix de comparaison (ancien prix)
  cost          Float? // Coût d'achat
  sku           String? // Référence produit
  barcode       String? // Code-barres
  trackQuantity Boolean @default(true)
  quantity      Int     @default(0)
  lowStock      Int?    @default(5) // Seuil d'alerte stock faible
  weight        Float? // Poids en kg
  dimensions    Json? // {length, width, height}

  // Images
  images String[]

  // Métadonnées
  status     String  @default("draft") // draft, active, inactive, archived
  featured   Boolean @default(false)
  visibility String  @default("public") // public, hidden, private

  // SEO
  seoTitle       String?
  seoDescription String?

  // Relations
  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Dates
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  @@index([userId])
  @@index([category])
  @@index([status])
  @@index([featured])
  @@index([createdAt])
}

// ======================
// MÉTIERS
// ======================
model Metier {
  id       Int                 @id @default(autoincrement())
  libelle  String
  services MetierService[]
  users    UtilisateurMetier[]
}

// ======================
// CaTEGORIE DE SERVICES
// ======================
model Category {
  id       Int       @id @default(autoincrement())
  name     String
  services Service[]
}

// ======================
// SERVICES
// ======================
model Service {
  id          Int                  @id @default(autoincrement())
  libelle     String
  description String?
  images      String[]
  categoryId  Int?
  category    Category?            @relation(fields: [categoryId], references: [id])
  metiers     MetierService[]
  users       UtilisateurService[]
  demandes    Demande[]
}

// ======================
// LIAISON MÉTIER-SERVICE
// ======================
model MetierService {
  metierId  Int
  serviceId Int

  metier  Metier  @relation(fields: [metierId], references: [id])
  service Service @relation(fields: [serviceId], references: [id])

  @@id([metierId, serviceId])
}

// ======================
// LIAISON UTILISATEUR-MÉTIER
// ======================
model UtilisateurMetier {
  userId   String
  metierId Int

  user   User   @relation(fields: [userId], references: [id])
  metier Metier @relation(fields: [metierId], references: [id])

  @@id([userId, metierId])
}

// ======================
// LIAISON UTILISATEUR-SERVICE
// ======================
model UtilisateurService {
  userId    String
  serviceId Int

  user    User    @relation(fields: [userId], references: [id])
  service Service @relation(fields: [serviceId], references: [id])

  @@id([userId, serviceId])
}

// ======================
// DEMANDES DE SERVICES
// ======================
model Demande {
  id                  Int      @id @default(autoincrement())
  disponibiliteBien   String? // "LIBRE" | "LOUE"
  description         String?
  contactNom          String?
  contactPrenom       String?
  contactEmail        String?
  contactTel          String?
  contactAdresse      String?
  contactAdresseCp    String?
  contactAdresseVille String?
  lieuAdresse         String?
  lieuAdresseCp       String?
  lieuAdresseVille    String?
  optionAssurance     Boolean? @default(false)
  demandeAcceptee     Boolean? @default(false)
  nombreArtisans      String? // "UNIQUE" | "MULTIPLE"
  createdById         String
  serviceId           Int
  createdAt           DateTime @default(now())

  createdBy User             @relation("DemandeCreePar", fields: [createdById], references: [id])
  service   Service          @relation(fields: [serviceId], references: [id])
  artisans  DemandeArtisan[] @relation("DemandeArtisanDemande")
}

// ======================
// LIAISON DEMANDE-ARTISAN
// ======================
model DemandeArtisan {
  userId    String
  demandeId Int
  accepte   Boolean?  @default(false)
  devis     String?
  rdv       DateTime?

  user    User    @relation("DemandeArtisanUser", fields: [userId], references: [id])
  demande Demande @relation("DemandeArtisanDemande", fields: [demandeId], references: [id])

  @@id([userId, demandeId])
}

// ======================
// TRANSACTIONS (PAIEMENTS)
// ======================
model Transaction {
  id            String   @id @default(uuid())
  userId        String? // l’utilisateur qui paie
  provider      String // "stripe" | "paypal"
  providerId    String? // ID du paiement Stripe ou PayPal
  amount        Float // Montant payé
  currency      String // "usd", "eur", ...
  status        String // "created", "succeeded", "failed", "refunded", ...
  description   String? // description du paiement
  referenceType String? // "product" | "demande"
  referenceId   String? // id du produit ou de la demande
  metadata      Json? // données additionnelles (cart, items, etc.)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
}
